morning everybody david shapiro here with another early morning update um let's see we have been working on oh actually here let me cancel uh half blocks real quick okay uh there there we go um okay so this is cognitive architecture research update um i have added to the diagram because there's another microservice that i need which is the embedding microservice um so i've introduced i've introduced the nexus which is um here it's publicly available um and i've done a little bit of updates on the nexus um so the nexus is the is the the core the brain of artificial cognition um and then the conductor this will be later on i've also done research on the core objective functions but then i started working on a simulation microservice and we'll get in we'll get into that in just a second but then also an embedding microservice which i wrote a while back using google's universal sentence encoder because it is fast and free um okay so first let me just show you get you up to speed i did a couple things to fix the um the simulation service so let me just zoom in here so what i did was this is the same load last scene generate an event given a backstory and a scene so generate an event then you generate a new scene and then you save it and then you summarize the backstory including the new scene and then it repeats so let me show you what that looks like i've got an example here so given the following scene and event write a new scene so backstory this is this was running the uh the example so it invented you know the men were playing one loses uh he practices obsessively um so this is the this was the original scene and then here's the event the man who lost the chess game to the other man quickly defeats him the next time they play taking his revenge so then here's the new scene that it generates the man who won the game is shocked and he can't believe that he was beaten etcetera etcetera so you can see it's much more coherent now um so the two things that i did was i changed it from world state to scene and then i added the backstory which just takes all of this the scene event and the new scene and summarizes it um and so the it'll recursively summarize it so that the most recent information is going to be the most reliable information or the most complete and then the older the information is the more concisely it will be summarized so you know it's just a few basic scenes given the following scene an event write a new scene write a concise summary of the following and then given the following scene imagine a rarity event so i have this so you can swap this out so you can say like likely rare um extremely rare or dangerous event or whatever so you can modify it describe the event in one or two sentences so you give it the backstory you give it the current scene and then it generates an event those three prompts we've got a text-based simulation i'm working on putting it together as a microservice and so if we go back to this instead of vision this will be we'll call it simulation um so it'll be the simulation microservice let's make this a little bit bigger um i'm being i'm being ocd about this there we go simulation okay so the simulation microservice is going to feed stuff into the nexus but it's also going to read stuff back out because eventually what's going to happen is the output will be in the nexus and so then the simulation will need to be aware of what our agent is doing um which you know here's the agent so that's like what am i capable of there's a whole bunch of other services this is going to be like a big radial spoke um thing before too long so uh you've seen what the simulation does um blah blah et cetera et cetera okay so we've got we've got the simulation i've got to just code all this up into a finish the microservice now you see i've got a whole bunch of functions here so these are all the micro service functions so i've got nexus send nexus search nexus bound and nexus save there's a there's a fourth function actually which is fetch so these are all functions that i've added into the nexus service so the first one is add which is just it's a super simple you send a message it gets registered in the nexus and stored with a vector so you can search later so the second function is search required vector field count etc what this does is it you send it a vector and you say give me all memories that are relevant to this vector um we're going to assume i might just remove the field um because we're just going to assume that that everything is going to be in the vector or in a field named vector so probably remove that just to simplify it and then uh so this this returns a um this returns a list of all the most similar memories uh which is uh so so the reason that this is is because human memory is associative so like let's say you've got a memory that you're like playing chess for instance in this example so you want to look for things that like okay what was the you know give me all the memories that we have of you know um playing chess and revenge and stuff and so you immediately pull all relevant memories to whatever's going on and then you you can then use that to construct or reconstruct memories rather and then that will also speak to your current situation now associative memory is one of the primary ways that humans also rapidly generalize right because um deep learning or uh what is the what is the term i don't remember but like if if knowledge and skills become deeply embedded in your mind so that you can just use use it intuitively you don't need to think about it that's one kind of learning right and that is that is the kind of learning that happens from from deep learning transfer learning fine tuning where it's so deeply embedded you don't need to think about it but we also need to have an agent that is capable of thinking and say okay i don't know i don't have an intuitive model of how to do this but i need to think through this and that is where associative memory is critical now the other thing other than associative memory is temporal memory which is what the bound function is for so this allows you to say okay i've got a specific memory that i've zoomed in on now give me everything in a window like the last 60 seconds and the next 60 seconds or give me an hour's worth of memories around this critical event so that i can fully understand and reconstruct what happened so that's those are the two search methods is is associative and temporal now i've also got fetch which um says okay give me all memories that have that have um you know a field with a specific value so this will be required because um when you're dealing with the microservices you have you have every service that contributes to the nexus is going to have a service name that registers this will be really critical especially for the conductor so the conductor will need to be able to say who is talking here so the conductor will need to ask the nexus give me everything that the core objective function service is doing and so then the conductor can say hey core objective function service you're acting up or let's say that the core objective functions are trying to train themselves better so they'll they'll ask the nexus hey give me everything that um that the agent and output and input has given so that i can look at these past events and come up with better predictions for the future that sort of thing so you need to be able to to not just search for associative memories but say give me everything relevant to this particular service or a particular uuid so for the nexus send function um i have this function it'll handle the time so it'll put a timestamp on when the memory is is sent um it'll add a uuid so that every every memory has a universally unique identifier it will also add the prefix to the content so that so that in the in the message payload you've got just a little bit of context as to what this memory log is right because if you look at any log files there's going to be a lot of stuff at the beginning saying like to give you a little bit of context of like where the log came from what is the purpose of the log um and so the prefix is just going to be in every message that the the the the simulation sense so it'll be sensory input scene is this one um so that way in the nexus when um other services are looking at those memories it says oh this is an input thing i know i know what this is or um this is my you know agent model this is so i understand what i am doing um so on and so forth or output it says this is an action that i'm taking on the world um so that'll add just a little bit of natural language context to it and also one thing that you'll notice is that um we're basically getting to an abstract layer of programming where instead of everything being deterministic and functional um most of the decisions are going to be based on natural language and you're going to be blown away by this because this is an entirely new paradigm of programming and this is what i mean by artificial cognition so anyways the payload for the nexus send you add the time the uuid the content the vector so this is this is i had to go resurrect um another micro service that i worked on so i used to call it the use microservice but that's not very clear as to what it does um so it's the semantic embedding microservice um google universal sentence encoder you can do this with uh openai now but uh universal sentence encoder is both very fast and free and it's also it runs perfectly fine locally on my cpu let me actually show you what this does okay it's still running and so i have a client that'll just send a couple of things and look how fast that was 0.03 seconds to get three semantic embeddings that are 512 dimensions each um so that's stupid fast and that's faster than openai right now um so that's what that's what that's all that this service does the embedding service and so you can see that here it's also very short this is the smallest micro service you'll ever use so all it does is it loads um universal sentence encoder large version 5. it's about 100 times faster than version 4 and it produces vectors of the same size basically you send this microservice a list of strings and it'll send back a list of vectors and strings one thing that's fun is that um it uh it is uh they are um blah what am i trying to say uh they're they're json ready um so one thing is that is that numpy arrays are not json serializable um and so what i do is i just go ahead and render it out to a numpy string to a list to a string and so then you have a json object that contains a string and you can see what it looks like here so you've got uh you know the the object here where it's uh it's a string and actually since it's a list i might be able to take that out i'll do some experimentation um because uh json can handle a list of numbers so i might be able to save a step and save some processing go back to the drawing board anyways so it returns a list of dictionaries it has just the string and vector pairing and that's it and so that's all you need actually yeah i can probably i can probably take that out yeah yeah yeah yeah anyways okay so i'll just do this one little thing um actually that's gonna break a whole bunch of other stuff i'll go back to i'll go clean it all up later okay where was i i think that's actually about it so there's three micro services that i'm working on um the nexus that was the first one i gave a demonstration of how this does search earlier so one thing is by switching to 512 dimension vectors one these memories are very short so like if you look at each of these sections it's just a few sentences right we don't need a vector that is larger than this in order to do search because this is very very soft search um later on when we have more powerful machines better compression and so on yeah we can use a 10 000 uh dimension vector for every memory but right now the vectors are going to be larger than this right so you see this selection that i have this selection is a thousand bytes right but then if you go here this is 512 32-bit floating point numbers so that's um that's roughly the same size in memory i think yeah so there you have it i think that's a complete enough update i'm running out of time anyways let's see time check 13 minutes yeah so just wanted to point out all this is publicly available i'll make sure to do a git push and commit um so but yeah here's the nexus um which is the the beating heart the memory which is here you can see this so this is the central point for artificial cognition which is why i started there and second is the sensor input which is here the simulation so in this case it's it's running a scene-based simulation text simulation that will push um that'll that'll give our our agent a virtual environment to work on and then supporting all this is the semantic embedding microservice so there you have it thanks for watching um like and subscribe and consider supporting me on patreon thanks for watching