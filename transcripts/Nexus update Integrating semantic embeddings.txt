morning everybody david shapiro here back with a new video sorry it's been about a week um i was out of town at vmware explorer which i can make a video about that if you guys want um for some background virtualization is my day job that's my profession and actually my understanding of systems engineering and large systems plays a huge role in the design of meragi so so that's one update another update is i just received my book um not my book but a book that i bought producing open source software um it's a little bit older some of the reviews said that it's dated um i think it's what 2005 2006 but that it is still good information um obviously it's a 16 year old book and this is before github but i'm still going to do that so that i understand a little bit more of the history of making open source software so that being said um i've started disabling issues actions and discussions on my repositories um because this is still very much in the early experimentation phase um it was probably premature of me to like create a an open invitation for collaboration um so if you could please um a lot of this stuff is not open for discussion yet um it's still very much in the like white boarding kind of experimenting around and one thing that really kind of um is a major distraction is some folks try and jump in and make suggestions um before fully engaging with the material and understanding um what you know like the theory behind it like i've written two books on this um plus i have a whole slew of videos and so um and some people i know that they mean well um but some people are very insistent about you know they want they want to modify the way that things are being done and they haven't done the work to really uh be onboarded which is a big reason that i'm making these videos is so that if someone really wants to they can you know get caught up that's also why i'm writing these books so anyways for the sake of reducing my own distraction level um just think of these videos as onboarding material for you to get caught up if you want i've also thought about disabling comments on the youtube videos just because they're more distracting than anything else um so that might be the direction that i'm going so that it's more of a one-way conversation because i realize that's why i enjoy writing books you know like i send out a book and someone reads it and then like i don't you know like someone can give me feedback if they want but i don't need to hear anything some folks believe that uh that uh debate is the right way to proceed which i disagree i've learned infinitely more by reading books than debating people um so yeah if you feel like debate and um and arguing is the right way to go then please just go away i don't have time for that um okay that being said um did a little bit of housekeeping um all right so working on the nexus so i realized one of the things that i was doing wrong was i was trying to optimize prematurely um i knew i knew someone knows someone i haven't talked to him in a while but he would poke fun at himself because he was a prematurely optimizing um coder um and it's like because you you get you get to a point where you've got something working and you just want to fiddle with what you've got rather than continue building new stuff so let's let's get this let's get the thing working and let's get the whole thing working and then we'll move on um so let's see embedding service so what i'm doing today well first let me get you caught up with what i've done so this is the nexus service and you can see um let me go back here to the nexus all right so that basically what the nexus does is it creates a log a bunch of log files if you're from systems engineering or other places syslog um is is basically what was this was inspired by um and so here's an example where you've got content bacon it's just one word microservice test time stamped uuid and a vector so this is kind of like the bare minimum um kind of uh of of payload that the the uh excuse me that the nexus keeps content uh con uh keeps track of there we go so the content would be obviously this is just one word um but it would be a you know up to a page or so of text it could be a thought it could be a sensation um you know sensor input it could be output decision whatever um and then the originating microservice so this is critical uh later on once we have the the conductor going time also critical because there are two primary ways that human memories work or recall one is temporal and the other is associative which is what the vector is for okay so um and rather than have rather than have the text file just be a uh a text log file um i switched it to json i had it that way before and then um someone i think it was either in the discord or on youtube made the helpful comment of like hey you should just do it all in json i was like yeah you're probably right i'll do it do it do it in json um and you can see that since this has some standard fields it would lend itself to being stored in a relational database but for the sake of just experimentation something that is human readable is good um i will not argue that point yes this will eventually be stored in a database a semantic search database like milvis solar elk stack something it's not going to be stored in json files forever now that being said there's a lot of other stuff that needs to happen once this gets out of mvp phase so this is still mvp keep that in mind it's this is to demonstrate this is a toy level example to demonstrate how it's going to look and feel so what i'm doing today is i'm going to take um i'm going to merge two services and so the reason is because after thinking about it i realized like okay here is the smallest micro service you've ever seen and this is used in exactly one place the embeddings are stored they're only stored in the nexus nothing else stores them so why bother having this as a microservice that everything else can use um so i'm just gonna merge the um the embedding microservice with the nexus microservice and call it a day and that'll be that so let's do this um just basically copying what works because like if you only have 25 lines of code that probably doesn't need to be a microservice now that being said i might end up eating my hat and um and needing and embedding microservice elsewhere but remember the nexus is going to be responsible for semantic search um so it's going to be the primary producer and consumer of these embeddings which another reason that this is good is i don't want to have the nexus be dependent upon any other service the nexus is the hub so of all the microservices in meragi the nexus needs to be the one that is 100 independent because this is the one that fires up first this is the primary microservice so it's important to get this done uh correctly first um yeah so that's that uh let's see yep so we'll do embeddings payload and then that would be um need to make sure well we'll we'll get this tested and the only place it's really going to be used is going to be here when you do add so embeddings equal embedding payload content so that's going to be the actual message um and i think that's that uh let's see vector equals uh numpy yeah okay so i think i can do embeddings numpy to list i think that'll work okay so then we'll do payload vector equals in bettings.numpy to list it took a while to figure figure this out because i wanted to get it in into a format that was easily renderable and sent via um oh actually you know what i probably don't need to store it as a list anymore i can store it as actually no since i'm saving it as json it needs to be json renderable a numpy array is not json renderable um okay so there's that i think to list is a function or a method so let's call that um is that it was it just like copying over a few lines of code probably um okay so i'll test this in a second but first i'll bring you up to speed with what i've done so add pretty pretty straightforward excuse me i'm a little flimmy anyways so add very simple very straightforward is exactly what it says on the 10. um we'll remove vector because all you need is the content um and we'll assume that you'll also have a microservice and then the nexus is going to be responsible for adding the timestamp and the uuid again no need to no need to add this information from other on other services to to duplicate it right because if you have a hundred different services all doing their own time stamps and uuids why you can do it in one place you can do it right here same with the embedding so we're just consolidating bringing it in into the nexus same as the vector or the embedding yeah and so it'll have the content the microservice the timestamp the uuid and the vector and so if you look at this example oh i deleted it keep it in the editor yes so all that all that's going to be sent from the microservice is this um i am going to add another field so there will be another field it will be um model uh so the model will be used so that because what the micro services are going to do over time is they're going to use their own fine-tuned models and so the model name might be something like you know fine-tuned core objective functions and we'll probably just have a date stamp right so like 2022 0903 you know something like that might be what the model name is and so that way the machine will also be able to keep track of the performance of individual models so the microservice will tell you which service created a message because you'll need to be able to you know each service will need to be able to keep track of its own contribution um there might also be another field that i'll add it might be something like like like context or something so context would be like what is the purpose of this message so you might say like sensory input um something like that typically what i've done is i've copy pasted this into the beginning of the content um but i realized that there that like the if uh the context might also be like a category right or type um so i'll probably add something like that just so that way it's a separate field um yes but um the the nexus microservice is kind of agnostic so what i've done in the past actually is um is in order to test it to make sure that it has all the necessary fields is you do something like um result equals um dict and so then you say uh what you do is so there's a rule of thumb in python where it's better to ask to to try and fail than ask permission upfront which is why i wrap everything and try accept which that's good practice anyways um for for a web server because if it fails you want to send back an error message right and so i just say okay capture everything and if it blows up whatever it does give me a little bit of log output and then send back the error message it's super simple um you know and you can be really mean there is a one of my friends on on his discord he posted like the the the alignment squares so like the chaotic evil one was like you returned just 200 even if it errors that's the chaotic evil uh web server um way to go and i apologize if if uh people are lost on on that okay so but what you can do is you you can rather than test um the the like check like if this if this key is in in this dictionary you just attempt to set it so you say like um payload time equal or result time equals payload time um and if it's not there it'll error out right and so then what you can do is in order to verify that everything that you need um is there and instead and actually since the payload is is here we would probably actually just do result time equals time and then result uuid whoops result uuid um but what you can do then is you switch over and use the result first thing and so then you say result content equals payload content because you want to fail fast right if something's missing you don't want to go through the trouble of doing the embeddings actually the embeddings are going to be implied here so we don't need to test that um actually no that's fine so result content equals payload content so that'll bomb and then because if if the content isn't there then the embedding won't work so the result vector let's see result would i say microservice equals payload microservice and then what did i say let's see what are we going to add a model right we need a model result model equals payload model and there's a reason for doing each one of these independently rather than just saying result equals payload is because this assumes that all the correct keys are in there so that's bad so this is bad does not help um so what we're doing here is we're um validating the payload all right so we'll validate the payload so we instantiate a new container and we try and pull everything that we need into it so we got content microservice model and then um i think i'll do context because like category or type is too is too narrow because context for the context for a message it might not be like um you know it might be a conductor message right the conductor says uh like might issue its own i'll show you later um so content the only problem here is content and context um are the same word with one letter difference so that could get confusing hmm because model microservice content those are all very distinctive vector time uuid very distinctive content and context are very similar um all right yeah i'll use type um hell with it okay i think this should work um let's see so validate message that's done model done vector done microservice vector yes all that's done save log and we'll do result print result whoops no print result not save log irma gerd i had the wrong thing okay successfully added record okay so that should work um let's go ahead and test this so so we'll do uh python why does this look weird there we go python nexus 2 please don't explode yep so it's downloading um yes okay so this um this is a very frequent error message if you use the tensorflow and so this the the fix for that is you um you go to that and then you just delete this folder um i don't know why that happens but obviously like yeah it's a pain in the neck so basically you you do the file is there it just for whatever reason tensorflow hub can't find it and also so this is really fast it's like 20 milliseconds per inference um even on cpu and it can be even faster on gpu um but like at 20 milliseconds like i don't care um once i have a dedicated um platform so like if i'm running this on say for instance um a jets and nano or whatever um then that might make more sense because then you've got you've got a dedicated platform but again this is still experimentation these are also going to be run as containers containerized microservices so if it doesn't need any custom underlying hardware then that's also really good because from an infrastructure perspective if you can run a container on any underlying compute um that's it's it's more portable whereas if it has special hardware requirements such as a gpu that's going to limit your abilities to do stuff um cd nexus this is what i do professionally so that's why i know that um and i was just at a vmware explorer so um i have a lot of insight as to where the industry is heading in terms of in terms of edge compute and ai hardware it's going to be a wild ride we're going to be running large language models inside of offices and stores within three years probably two years honestly with the way things are going okay uh so then we'll do python test two this should bomb says model yeah i bet that didn't i bet that didn't work um yeah because it's missing things so if we go and look at test two i don't have the right things okay so i don't need vector because that's going to be added so content bacon microservice test model equals um we're just going to say n a because there is no model here there is no spoon um actually here there's no spoon um and then the other thing that i needed was type um and so the type here is going to be um this is just going to be a a a test okay and then let's add a time from time import time and then we'll see how long this takes um oops we don't need to instantiate that every time so we'll do start equals time end equals time actually no we don't need that so we'll just be print time minus start there yay look optimizing why do you think why do something in two lines of code when you can do it in one that can get away from you especially with powershell where you can chain things end to end and do one-liners just because you can do a one-liner doesn't mean you should do a one-liner okay so let's test this real quick this is not the most helpful output but it was enough of a clue to tell me where it bombed because it got to this point and it's like hey this is missing okay um let's try it again that input must be a vector got shape zero i think i knew where that i know where that bombed i think that bombed on the embedding yep i bet that's where it failed i bet that's where it blew up hey hoss okay so payload content so let's do this so let's just wrap it in a list so that it's a string inside of a list and also let's switch to result content yeah so we use payload you see it's only used here and then it's used there but then ever after we use result so that way it may we make sure that every microservice gives you the necessary information otherwise you want it to kick that back out because it's like no go away you didn't use you didn't you didn't fill out the blue form that requires a blue form a gold star to whoever gets the reference your blue okay all right test and then it's gonna blow up again oh hey look at that okay um yeah so it took 0.03 seconds so 30 milliseconds on average 28 29 32 33 so 30 milliseconds on average to send a message to the nexus and build the um and build the embedding and and send back a confirmation um and so here you see we have a whole bunch of new logs and this is what the logs look like so i added the indent so this wastes a little bit of text space but i added the indent so that it's easier to see so content oh it's also sorted so this is a cool thing that you can do with um with json so json dump payload out file ensure ascii false this allows it to encode in utf-8 really important you can do ensure ascii true but you can get some weird nonsense with that actually we don't use load data so i can probably delete this function yeah oh no actually we do okay um dude never mind um insure ascii false this unsure this allows you to encode everything in utf-8 which can be critical especially once you're dealing with multiple languages other symbols sort keys equals true so sort keys is what may it this will ensure that everything is always in alphabetical order and since every log file has just these six or so how many one two three four five six seven seven fields they'll always be in the same order which is nice because then you know what you're looking for so content microservice model time type uuid and vector um so this is kind of what the data is going to look like and then you see here's the actual embedding it should be a 512 vector value embedding which means that like yeah and it's going to be the same for everyone because i just sent the same one over and over so every memory so here's a problem every single memory that we just created is 14 kilobytes so let's do a little bit of math so let's say that uh a future version of moragi is running 15 50 uh uh inferences per second um and each one has an embedding um it'll add a little bit because the um the the message will be a little bit longer so let's just make this a little bit longer so we can get um well actually here whatever we'll just say 14 kilobytes so 50 50 messages times 14 kilobytes so that's 700 kilobytes per second um that this could be generating later on so this is why this is what i'm talking about like optimization is going to be a big thing and i'm not going to worry about it right now because that's just you know i keep i keep making these changes so like let's not let's not uh try and eat the whole elephant at once okay so 700 kilobytes per second times 60 seconds so that's 42 megabytes per minute so we're looking at like this is this is almost as big as a wav file right as a lower quality wav file which is you know old old-school music um so 42 uh we'll say 42 megabytes um uh well here 42 000 divided by 1024. so 41 megabytes per minute so 41 megabytes per minute times 60 2.46 gigabytes an hour divided by 1024 so that's 2.4 gigabytes an hour 2.4 gigabytes an hour times 24. 57 gigabytes a day of thinking um or or of of data um obviously the embeddings are um you're not going to pay for for all that uh 57 gigabytes a day times 365. so that's 21 let's see divided by 10 24 so that's 20.5 terabytes of data per year that is obviously way too much but if you think about it though that's not unreasonable if you were to record every single sensation and thought and motor output that you had 20 terabytes seems kind of reasonable right um so just that's why like this will need to be optimized it will need to be summarized um there's going to be a whole bunch of other stuff that happens in the background and i think this is enough for today um because i i've merged the embeddings um into it and also reconfigured the um the way that it does logging um so yeah it's much more much more interpretable um yeah so i'm satisfied for today so anyways i was talking about things that the nexus is going to do in the future so in the future so we'll say distant future um one thing is a blockchain so imagine here's here's why blockchain imagine that you've got an instance of meragi running um for your your home life right it's a smart home device it records everything it sees and does and hears um that is a huge privacy thing and so you don't want just a bunch of json files stored out here on your smart home device or in the cloud somewhere where it would be like you know um dave is meeting with secret spies from you know wherever you don't want that kind of data out there um now but then like let's say you're a an academic institution um so blockchain for privacy mostly um an academic research institution and again you don't want your data stolen in fact many uh researchers as part of the grants that they get have very very stringent privacy controls um ditto if you have an instance of meraki helping run a hospital you got patient records to to protect so um because blockchain um has well here let's just do do do do no that's the wrong one there we go so blockchain has several advantages um so we'll do blockchain for privacy um and so what are the advantages of blockchain um it's immutable i cannot change records later so this is critical for legal reasons it's critical for um you don't want your your agi's memories tampered with um immutable uh tamper proof so uh that's basically two sides of the same coin um but like uh so again records cannot be changed um distributed right so it means it can be um resilient difficult to delete um so that's another thing and then there's uh consensus is another uh is another thing which means that um [Music] messages uh or well we'll say transactions transactions uh must be accepted by a quorum so imagine in the future you have several microservices all running and for every message that makes it into your ai's brain um you ha it has to be approved right um so that that gives you a gating or a filtering mechanism um so this is like uh so it's a dating or filtering mechanism um so there's a lot of reasons that blockchain is good now okay so obviously you know you don't want to store your private data in clear text you want it to be encrypted but blockchains are not necessarily the best thing for being searchable they're not necessarily known for speed that's not their point so your raw data will be stored as a blockchain um so we'll just say like use to store raw data probably the embeddings will not be stored in the blockchain only um this stuff so then well what about the embeddings so then you might have um a semantic search database of some sort like milvis pinecone we v8 something like that this will store um high speed semantic search and this will be loaded um loaded uh from the blockchain and so what that does is it separates out your long-term storage um permanent long term um so that allows you to say uh you you have your permanent long-term storage loaded from the blockchain so that means your semantic search engine can be updated it's decoupled um so it's loaded from the blockchain um it can be can be ephemeral if uh but it also ephemeral or interchangeable right so let's say let's say your semantic search database you start with um so you let's say you start with sqlite then upgrade to elk stack then upgrade to pinecone and so then your your your search engine gets better over time um and then there's a third layer so the third layer is going to be a knowledge graph so um this uh someone someone in the discord server suggested this and i had already been thinking about it but they brought it up in conversation um and and so this would be like a third way of of storing and searching this information so similar would be populated would be populated from blockchain data so if you need to regenerate it you've got you've got your original immutable data source but um let's see can be regenerated as needed we'll say that's another generated as needed can be regenerated as needed but uh so this um organizes thoughts memories around topics rather than um [Music] sequential in time or just a search index and so what this does is it organized organizes things around you know particular events or other relationships which means that it's it can be a lot less energy intensive to load a particular event or topic or task or whatever but these things can happen um you know depending on depending on what it takes to update them because the knowledge graph that takes a while right so maybe um maybe gets updated periodically via a background let's say sleep function um [Music] and this one can be updated in real time right and so uh the the combination of these three things which don't exist right now right now it's just a series of log files um but these three things are kind of on the roadmap to for the nexus to be complete is to integrate these three technologies blockchain semantic search and knowledge graph once those three are all in here on top of optimization right um which i guess you know semantic search that's a kind of optimization because it's a high velocity search blockchain that is not optimization that is a security thing that is 100 security um so this would be a private private ledger um [Music] private ledger um maybe several nodes um so like you might have you might have a copy of nexus running at home cloud and on your phone right and so you you can have uh you have just a few a few nodes but that means that like you know your phone gets compromised um you you know you delete you remotely delete your phone and your a your your personal agi is still intact but still secure too because if the genesis block is deleted then a blockchain is useless as long as it's encrypted encrypted well enough okay anyways um i think that's enough for today you should be brought up to speed yeah thanks for watching