hey everybody david shapiro here for a random video let me tell you what's going on okay so there is an unmet need in our domain where we're trying to build artificial cognition and we need to rapidly experiment and we want to do vector search embedding search the problem is the only tools for this are all like so there's we v8 which we v8 uh it allows you to store objects but it's docker only um which is it's fine or i don't know if it's docker only but you know it's its own server it's a whole server um then there's feis which is facebook ai similarity search which does vectors only it's great it's super fast they can do a billion and it can do clustering but it does not allow for any other context or data to put in it it's only a component it's not a fully fledged service and then there's milvis there's pinecone there's a whole bunch of stuff out here that are like enterprise ready and cloud ready but we're not there yet right i need something that is fast and disposable and lightweight like sql light but i need it for vectors that doesn't exist so you know what i'm going to do i'm doing vdb light so vector database light i'm going to do my own and that's going to be hosted on pipi um so i'm just documenting the process um i've written a module before i just took it down because i realized it's super out of date um and you know you see last last updated three years ago this was my this was my my pre my proto raven work my proto agi so maragi morphed into raven so it's been abandoned for three years um but i've done it before so let's just get going and see what we can do so the idea is it's pretty simple we're going to do sqlite but for vectors um there's a lot of unmet needs so for instance we need to um you know just keep it in memory right just a memory based vector search disposable also writing it to file right that that would be another great thing to do so let's get started um first i'll just copy my from my old from meragi we'll do we'll save this in um bdb light so that'll be my setup thing and this is what i use to uh set up dot hi this is what i use to actually uh upload it to um what you may call it uh uh wow my brain is not working right now it's a pi pi there we go okay so then we'll rename this to vdb light and we'll do version we'll just do 0.1 and description will be vector database light and the url we'll take that out because the url will be vdblight description equals long description which will be that'll come from the readme long description content type text markdown author david shapiro author email um we're just gonna say no one at gmail.com i don't even know my email address packages vdb light zip say false okay i think that should be fine so that's the first thing but now we need something that will actually work right let me zoom in a little bit so what is it that we're actually trying to build here um that is a good question so i need to do some testing right what are the requirements so let's just do some rapid prototyping let's do a language p python um okay so one of the requirements is in memory uh vector similarity search uh so basically we just start something up run treat it like like sql light and then you know we we need to be able to add stuff so index them and then um and then and then retrieve them i am not an expert i have no idea what i'm doing this is going to be usable it's not going to be optimized at least not the first version um if this takes off and we get we get people contributing that would be great you know if we can get some people um you know doing this in c plus plus so that that way it'll be faster more optimized that'll be great um okay but uh we need um objects and or metadata attached to vectors so what i mean by this is like in a relational database a relational database is basically just like a spreadsheet right so you'd have like uh row row one and then you'd have like um you know text info here and then you'd have a vector here and then you might have like um a timestamp right so we want i want to have this kind of stuff right we need to have an arbitrary amount of information with each record now here's the thing though because i'm doing agi research artificial cognition research i need more than one vector to store to be stored with with a bit of information so for each item for each object or record or whatever what i need to do so let's just say row two um it's gonna there's gonna be an arbitrary number of of uh information with it so like you know this will be you know agi memory one right um it'll be stored like that um and then we'll have oops vector one you know which would probably be like 512 uh dimension um similarity vector and then i also want to store uh vector two which might be a uh you know um 2048 uh similarity vector um because here's the thing um you want to have different different levels of granularity that you can search because there's going to be different speeds but you can also have vectors that have different purposes right and then i also want to have time stamps because all memory so this is this is critical absolutely critical if you have nothing else associated with a memory you need a timestamp because there's a there's a temporal component in human memories although the temporal component in our memories is all relative so you say i had you know a ham sandwich on the same day that like the lightning storm soaked us on our hike right all of our memories are relativistic because we don't have a unix computer in our head giving us a time stamp but machines are lucky because they can have a number that says it happened at exactly this time um so then you might also want to have like um file name you know you want to have you want to have an arbitrary number of fields that are then associated with a given vector right so this is this is kind of the goal i'm setting for myself easy right um all right what do i know what do i know that we need the primary thing that we need is um we're gonna need import pickle i'm just gonna save this as a pickle um we could probably do cpickle for faster i don't care i'm not trying to optimize it i'm just trying to get it to work import numpy as np or whoops numpy as np we're going to do dot product similarity there are better ways of doing this so we're just going to do test.pi just i i have no idea how far i'm gonna get today um make sure that we're recording right yes we are recording eight minutes in okay so uh saving it as a uh saving it to file that's gonna be an option it's not going to be required um let me under meragi init dot pi okay and it's been anyone who watches my youtube channel you know that i'm like phobic of object-oriented coding it's not that i don't like it it's amazing i just got out of the habit of doing it because of rapid prototyping so i need to i need to remind myself what i'm doing that's fine okay so we will come back here do class server we're going to change this instead of class we're going to do vdb one thing i do remember is that when you're declaring a class in python it is best practice to have it the first one uppercase i don't know if it's it might actually be a requirement if it's not it might not work but i don't think you can do like vdb it has to be uppercase v lowercase db okay so class server def in it so we'll just copy a couple of these things um all right we don't need a port this is going to be local only um and then the fields uh let's see field will probably have um oh so actually from this because the the whole point of of maragi microservices architecture for robotics and artificial general intelligence the whole point of that was to was to serve as the like the heart the framework of it um but i realized that it wasn't quite right and so that eventually evolved to the current cognitive architecture that i'm working on um okay so we don't need the port that's fine um and for the fields i don't think we need that as well because we oh stream of consciousness log yeah because this is just going to be so let's just take that out i might need to add it back that's fine um yeah so when we when we declare this well i guess like sqlite it's kind of implicit um yeah all right so we'll we'll just say we'll start with a um with an empty list list and so we'll call this the little this index would not be quite right um we'll just call this data uh that's fine and so basically what you'll do is once you declare your vdb object you'll just do dot like dot data append to add to it and then once you're ready then you'll do like an index or a search on that data i think that's how we're going this is going to be brain dead simple um okay so then let's see validate message result field equals message field return true result filter html head run oh yeah this is the actual server i could have sworn this was like for field in self fields i don't know if this was complete i might not have updated the light the latest code return true result that was validate message it's not actually storing any messages here is it def run oh here we go um what am i trying to remember how to do new okay here we go payload self validate message self sock lock okay it is literally just that okay um so i think it'll be like deaf ad this is probably going to be a super boring video i might not even post it we'll see um yeah so validate message all right so validate a message is when you add a thing okay so we'll do validate our add and that'll be self and then it'll be we'll just say payload so the payload payload is a dict and that's fine um and so then what we'll do i think basically i'll do self dot data dot append payload this feels wrong i'm gonna test this and it's gonna blow up um okay so add and then let's just do like our most basic search function def search self um vector field yeah that should be it um oh and then count okay so this is where the rubber meets the road um okay so results equal list um and actually let me i'll probably just copy paste the functions that i've used elsewhere um did i do that here where did i use let's see we need that um i'm not going to worry about there we go search index okay that's basically this okay so instead of results we'll do scores all right for i in self.data so that's that's our thing um and what we're going to do so basically i want this to be really flexible so i'm not going to assume that the field is going to be in every item right because you might have different field names for different vectors and they might not be present in all of them so i will say let's see we don't need to worry about that so what we'll do is we'll do um try score equals similarity and we'll do we'll do i so i and then we'll do field so you're basically saying search this field this given field and then compare it against a given vector that i want you to search um so that'll be good and then the count is the number of results that you want to turn so i'll just set that to default five um okay so try and then accept continue so basically what i'm going to do is if this field is not present we're just going to skip it and move on otherwise we're going to as do scores append and what we'll do is we'll do um info equals i and then info info score so we're basically going to copy copy this record and we're going to then add this uh the score equals the score that we got um so basically this will be the the same the same exact item that was stored in it and then we'll do scores append so the scores is the result here i'm going to change this to uh results because that's a little bit yeah that makes a little bit more sense results append and then we'll just append info uh so that should give us the results and then what we do is we do ordered equals sorted results and then we do lambda d for d score reverse true so that'll that'll sort it by um top top down or you know descending order and then what we do is um we'll try and and do ordered equals ordered um so we'll start from the zero index and go up to count so if you only want the top five it'll just say okay here's the top five send them back and then we'll return i why am i doing that i don't need i want to send back the whole thing um and so then if but so here's the thing sometimes you might be searching something that is very small or the count that you want is going to be wrong and so i want it to just send it back anyways okay is this ready for testing maybe it is it still feels wrong i've done something horribly wrong i know that did i have a test in my uh old moragi code maragi in it pi static no this this is it dang okay i could have sworn i had some test some test stuff in there um yeah so fetch send and then what do i do next um okay so then if name equals main so then we say um bdb equals vdb do i have to put the parentheses in i don't remember i don't think so let me look at the uh oh it's so it's import moragi moragi server oh wait okay since it's declared here where am i where am i going i think it's just this okay um so when it's instantiated it's an empty list let's go ahead and add another function def purge self because i know this is going to be a function so we'll do self.data equals list that's fine um and then we'll probably need a like save function so that'll be pretty simple def um save and we'll do self and then file path uh and that'll be basically all we'll do is just save the list so we'll do with open file path uh right binary as out file and it will do pickle dot save let's see if i remember um at least self.data and then out file let me check the docs to make sure i did that right pickle python tutorial i'm trying to do all this from memory it's been a little while sorry um real python pickle dot save no pickle dot dumps okay object file okay pickle dot dump and then it's object file okay so it's self.data out file that's fine that should be good and then def load will be self and then file path and i will say with open well here just copy this it's basically the same function um pickle dot load file yeah so um self dot data equals pickle dot load and we'll change this to infile okay save load purge um add search we probably ought to have like a remove so like dell so like def dell um def dell self um and then you'll say like let's see how do we want to identify um we'll say uh feel field and value um okay so oops def dell oh wait no delete is uh there we go okay so we'll say um for i n self.data um try if i field equals value a equals self.data wait how do you do pop um dot pop i i think that's how you do it python pop list item so let's pop the in that index let's see python removes specific item from list without index i think it's remove is what i want the given very first element matching yeah okay i think that's the one that i want to do yeah so remove it's just something that matches that okay that's the one i want um so data dot remove i and it doesn't return anything does it yeah okay so we can so if it matches and then um if that whole thing fails we'll just say accept continue oops we don't need to duplicate that continue um and so this will delete everything that matches that specific value so if you have a vector or a timestamp so that that'll be that'll be one of the best ways so with a unix timestamp there's so many there's so much precision that um that you can basically treat a unix timestamp as a uuid um not always it's entirely possible that you'll get something um at the same exact time but let me show you how precise um this is uh let's see from time import time and so then you just do time and you see it goes out to one two three four five six seven seven precision so that's um uh let's see that's millionths of a second so um that's pretty pretty darn precise um the likelihood of getting two exact uh two exact um timestamps that are that are identical is very very low it's not it's non-zero right you can still it can still happen whereas so originally what i would do is um let's see from uuid import uuid 4 i think and then so then you do print string eu id4 and so what you can do is uuid uuid v4 is universally unique identifier version 4. there are enough uuid v4s that you can address i think every atom in the universe and so every time you run this it is it is pretty much guaranteed to be unique in the entire existence of all of history so if you want something that is guaranteed to be unique use uuid 4 it's quick and easy and you can see there's no real pattern to it um you know it's not like a burned in address it is there's a lot of stuff going on behind the scenes to ensure that it is pretty darn random um but you know there's also nothing wrong with just using time um for our intents and purposes time will suffice um yeah so if you if you pass in a field like you know if this is like um if field equals time or time stamp or whatever it is then um we'll just say timestamp um then uh then value might be and we'll just copy paste this so you're guaranteed to be like almost almost guaranteed to be 100 unique um let's see let's do first only equals false and so then what will happen is um so then we'll do a test if first only and so this is implicitly true if first only um then we'll just do return which means that like okay delete only the first one so we'll have this function available to us in case we want to only delete the first one that matches ideally in the future we'll have we'll have multiple things that allow you to to delete something but you know for again for our intents and purposes we'll say we'll use timestamp as the equivalent of our uuid that'll allow you to zero in on one we can you can also always add uuid back right there's nothing preventing you from having uuid could be in the payload to be in payload use it if you want um i think yeah it's up to you um and then you have you know whatever vectors uh will will have your similarity okay so um so now we need to load this up with something what do we load it up with uh let's do um let's go look at the feis um let's see boards data science fice yeah here we go so this woman wrote a really great write-up of feis turns out feist doesn't do what i need it to do um but we can do a couple of good things so let's see np random seed um we want vectors as type float32 and all right so we're doing how many dimensions so there's going to be 200 by here let me zoom in so you can see what i'm looking at all right so this is this is using numpy to um to generate some some random numbers uh and we'll just do this as like a way to to to test this okay so i'll just copy this because it's useful borrow code all right but i don't have a function that can they can do them as as one so we will do i don't know off the top of my head how to split up um how to split these up as as individuals so we'll do n one and then let's just print db vectors and the dimension will say 12. all right let's see if that works i might be completely losing my mind um cd vdb light python test okay that worked okay so we've got a couple of vectors um dimension as type uh can i just do the zeroth one does that work okay cool so then let's go ahead and do and let's do 200 because then i think okay cool and if we print out all of them so you can you can create this as a list of lists okay that's fine that's fine all right so then what we'll do is four uh vector and db vectors we will do info equals we'll say vector equals vector because i'm not creative like that and then i want like some random oh no we'll do from time import time and then from uuid import uid for bingo okay so then we'll do uh time equals time and so that'll be stored as a floating point number um you can also store these as a decimal i can't remember there's there's a way to there's a way to store um numbers in python as like literals uh literal numbers not floating point uh as decimals um it's not that important and then we'll say uoid equals string uid4 and that will be what we're going to register to the vector okay so then we'll say vdb dot add info yeah that should work let's run this and see if it blows up and if this works i'm gonna like save this video and just be like we're done for now because uh quit while you're ahead okay um let's add a function so def uh details and so then we'll just do like uh print um [Music] db uh db elements number and then we'll say len db uh no self.data and then what else there would um oh there's a way to uh show like size and memory um python show size in memory of list import cis size get cis get size of okay sure let's do it um import cis and then we'll say um print db size in memory and we'll do uh what was it cis get size of is that right yeah list one size of get the size list using oh interesting but why are they different sizes okay we'll do cis because i think i think the system reporting the size of it is probably going to be more accurate okay and instead of list one we'll do self.data um sure and then at the end of that we'll do vdb.details and let's see cls it's working it's really working okay so that i think is in bytes yes so that returns bytes um so let's uh let's add a thing in here so that it's clear what we're talking about and we'll do just bytes bytes there we go i can spell um okay and then the last thing we want to do is just search let's do a search um so we got the details here let's comment out um we'll just do the first one and then let's do uh let's do um results equals vdb dot search and let's see how did i define the search so we we give it a vector so let's do db vectors and this is this is going to be like an exact match right but let's find so let's do let's do the 10th vector and then the field name is is just vector here let's actually make that implicit so field will just equal vector unless otherwise specified and so then also the count we'll we'll leave that implicit as five um just because you know you never know you might have you might have just one okay and so then let's get um from p print import pprint as pp and then we'll do pp results let's see what happens it returned nothing it was too good to be true let's see how long this video is now um we're only 35 minutes let's see if we can figure out what's going on here um all right i suspect so here's here's why you don't want to do a try except is because it will often exception as oops so we'll do print oops um because you'll often end up with uh something that you don't want um so let's see where all did i use try pretty much just in the search loop and then here i haven't tested the delete functionality yet okay so let's see name similarity is not defined what do you mean it's not defined oh right because i copied another thing and i had a function named similarity but we can just do it we can replace that with np dot dot i don't know why i have this as a separate function i thought it was going to be more complex than that okay that's fine all right so where is similarity there it is okay np dot so now we should be able to well here let's leave that there just in case it blows up cls python oh hey look we have similar things vector array oh interesting okay so it's stored it as a nunpi array in memory i wonder if that's more efficient than storing it as a list who cares but you see it's sorted so this whole thing worked it worked cool i'm gonna save this on on pi pi and you'll be able to use it um and actually you know what because this works i'm going to go ahead and get this registered on pi p i and then show you how to how to use it yourself so give me just a smidgen of time okay it's up on pi pi look at this yi i did good okay uh let's make it let's give it a test make sure it works so we will do um pip install vdb light all right and now let's make sure that this little script that i wrote works this is the public test version so we'll do python uh no we'll do pub test.i and then we'll just jump in here and do python hub test np is not defined did you mean pp well darn it um from uh import numpy as np now that should have been in here okay whatever let's see what happens pubtest time not defined do i oh i i think i need to um i don't remember how to do this there's a way to tell it to in to import everything that it needs i don't remember how okay so there might be a small problem set up get ignore readmemoragi edit yeah because i i if you import all these in the init all right i'll look it up later important thing is i know that you need to import all these yourself and we will figure this out later import vdb light okay so let's try this again look at look how fast that is all right i will call this a day because that worked all right thanks for watching